////////////////////////////////////////////////////////////////////////////////
/// @brief QL parser wrapper and utility classes
///
/// @file
///
/// DISCLAIMER
///
/// Copyright 2004-2012 triagens GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is triAGENS GmbH, Cologne, Germany
///
/// @author Jan Steemann
/// @author Copyright 2011-2012, triAGENS GmbH, Cologne, Germany
////////////////////////////////////////////////////////////////////////////////

#ifndef TRIAGENS_QL_PARSERWRAPPER_H
#define TRIAGENS_QL_PARSERWRAPPER 1

#include <string>
#include <iostream>
#include <ostream>
#include <sstream>

#include "QL/ast-node.h"
#include "QL/ast-query.h"
#include "QL/parser-context.h"
#include "QL/optimize.h"
#include "QL/formatter.h"
#include "QL/javascripter.h"

#include "VocBase/query.h"

using namespace std;

////////////////////////////////////////////////////////////////////////////////
/// @addtogroup QL
/// @{
////////////////////////////////////////////////////////////////////////////////

namespace triagens {
  namespace avocado {

// -----------------------------------------------------------------------------
// --SECTION--                                                  class ParseError
// -----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
/// @brief Parse error container
////////////////////////////////////////////////////////////////////////////////

    class ParseError {
      public:

////////////////////////////////////////////////////////////////////////////////
/// @brief Destroy the instance
////////////////////////////////////////////////////////////////////////////////

        ParseError(const string&, const size_t, const size_t);


////////////////////////////////////////////////////////////////////////////////
/// @brief Destroy the instance
////////////////////////////////////////////////////////////////////////////////

        ~ParseError();


////////////////////////////////////////////////////////////////////////////////
/// @brief Get the parse error as a formatted string
////////////////////////////////////////////////////////////////////////////////

        string getDescription() const;

      private:

////////////////////////////////////////////////////////////////////////////////
/// @brief Parse error as created by Bison
////////////////////////////////////////////////////////////////////////////////

        string _message;


////////////////////////////////////////////////////////////////////////////////
/// @brief Line in which the error occurred
////////////////////////////////////////////////////////////////////////////////

        size_t _line;


////////////////////////////////////////////////////////////////////////////////
/// @brief Column in which the error occurred
////////////////////////////////////////////////////////////////////////////////

        size_t _column;
    };


// -----------------------------------------------------------------------------
// --SECTION--                                               class ParserWrapper
// -----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
/// @brief Parser wrapper
///
/// This is a simple wrapper around the C level parser functions. The wrapper
/// cares about memory allocation and deallocation and provides access to the
/// parse results
////////////////////////////////////////////////////////////////////////////////

    class ParserWrapper {
      public:

////////////////////////////////////////////////////////////////////////////////
/// @brief Create a new instance
////////////////////////////////////////////////////////////////////////////////

        ParserWrapper (const char *);


////////////////////////////////////////////////////////////////////////////////
/// @brief Destroy the instance and free all associated memory
////////////////////////////////////////////////////////////////////////////////

        ~ParserWrapper ();


////////////////////////////////////////////////////////////////////////////////
/// @brief Parse the query passed 
////////////////////////////////////////////////////////////////////////////////

        bool parse ();


////////////////////////////////////////////////////////////////////////////////
/// @brief Get a parse error that may have occurred
////////////////////////////////////////////////////////////////////////////////

        ParseError *getParseError ();


////////////////////////////////////////////////////////////////////////////////
/// @brief Get the type of the query
////////////////////////////////////////////////////////////////////////////////
        QL_ast_query_type_e getQueryType ();


////////////////////////////////////////////////////////////////////////////////
/// @brief Create a select clause
////////////////////////////////////////////////////////////////////////////////
        TRI_qry_select_t *getSelect ();


////////////////////////////////////////////////////////////////////////////////
/// @brief Get the alias of the primary collection
////////////////////////////////////////////////////////////////////////////////

        char *getPrimaryAlias ();


////////////////////////////////////////////////////////////////////////////////
/// @brief Get the name of the primary collection
////////////////////////////////////////////////////////////////////////////////
        
        char *getPrimaryName ();


////////////////////////////////////////////////////////////////////////////////
/// @brief Create a where clause
////////////////////////////////////////////////////////////////////////////////

        TRI_qry_where_t *getWhere ();


////////////////////////////////////////////////////////////////////////////////
/// @brief Get the skip value
////////////////////////////////////////////////////////////////////////////////

        TRI_voc_size_t getSkip ();


////////////////////////////////////////////////////////////////////////////////
/// @brief Get the limit value
////////////////////////////////////////////////////////////////////////////////

        TRI_voc_ssize_t getLimit ();


      private:

////////////////////////////////////////////////////////////////////////////////
/// @brief Query string
////////////////////////////////////////////////////////////////////////////////

        const char *_query;
 

////////////////////////////////////////////////////////////////////////////////
/// @brief Parser context. This is a struct that is used extensively by the
/// parser. It contains a pointer to the flex lexer, a pointer to the query's
/// AST root nodes and state information for memory management (GC) 
////////////////////////////////////////////////////////////////////////////////

        QL_parser_context_t *_context;


////////////////////////////////////////////////////////////////////////////////
/// @brief Pointer to a parse error
///
/// The parse error object is automatically created during parsing if a parse
/// error occurs. It will be freed automatically when the parser is destroyed.
////////////////////////////////////////////////////////////////////////////////

        ParseError *_parseError;


////////////////////////////////////////////////////////////////////////////////
/// @brief Flag if parsing has already taken place
///
/// Using this flag duplicate parsing and all of its issues can be avoided
////////////////////////////////////////////////////////////////////////////////

        bool _isParsed;
    }; 

  }
}

///////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////

#endif

// Local Variables:
// mode: outline-minor
// outline-regexp: "^\\(/// @brief\\|/// {@inheritDoc}\\|/// @addtogroup\\|// --SECTION--\\|/// @\\}\\)"
// End:
