////////////////////////////////////////////////////////////////////////////////
/// @brief QL parser wrapper and utility classes
///
/// @file
///
/// DISCLAIMER
///
/// Copyright 2004-2012 triagens GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is triAGENS GmbH, Cologne, Germany
///
/// @author Jan Steemann
/// @author Copyright 2011-2012, triAGENS GmbH, Cologne, Germany
////////////////////////////////////////////////////////////////////////////////

#ifndef TRIAGENS_QL_PARSERWRAPPER_H
#define TRIAGENS_QL_PARSERWRAPPER 1

#include "Basics/Common.h"

#include <iostream>
#include <ostream>
#include <sstream>

#include "QL/ast-node.h"
#include "QL/ast-query.h"
#include "QL/parser-context.h"
#include "QL/optimize.h"
#include "QL/formatter.h"
#include "QL/javascripter.h"

#include "VocBase/query.h"
#include "VocBase/join.h"

using namespace std;

////////////////////////////////////////////////////////////////////////////////
/// @addtogroup QL
/// @{
////////////////////////////////////////////////////////////////////////////////

namespace triagens {
  namespace avocado {

// -----------------------------------------------------------------------------
// --SECTION--                                                  class ParseError
// -----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
/// @brief Parse error container
////////////////////////////////////////////////////////////////////////////////

    class ParseError {
      public:

////////////////////////////////////////////////////////////////////////////////
/// @brief Destroy the instance
////////////////////////////////////////////////////////////////////////////////

        ParseError(const string&, const size_t, const size_t);

////////////////////////////////////////////////////////////////////////////////
/// @brief Destroy the instance
////////////////////////////////////////////////////////////////////////////////

        ~ParseError();

////////////////////////////////////////////////////////////////////////////////
/// @brief Get the parse error as a formatted string
////////////////////////////////////////////////////////////////////////////////

        string getDescription() const;

      private:

////////////////////////////////////////////////////////////////////////////////
/// @brief Parse error as created by Bison
////////////////////////////////////////////////////////////////////////////////

        string _message;

////////////////////////////////////////////////////////////////////////////////
/// @brief Line in which the error occurred
////////////////////////////////////////////////////////////////////////////////

        size_t _line;

////////////////////////////////////////////////////////////////////////////////
/// @brief Column in which the error occurred
////////////////////////////////////////////////////////////////////////////////

        size_t _column;
    };

// -----------------------------------------------------------------------------
// --SECTION--                                               class ParserWrapper
// -----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////
/// @brief Parser wrapper
///
/// This is a simple wrapper around the C level parser functions. The wrapper
/// cares about memory allocation and deallocation and provides access to the
/// parse results
////////////////////////////////////////////////////////////////////////////////

    class ParserWrapper {
      public:

////////////////////////////////////////////////////////////////////////////////
/// @brief Create a new instance
////////////////////////////////////////////////////////////////////////////////

        ParserWrapper (const TRI_vocbase_t*, const char*);

////////////////////////////////////////////////////////////////////////////////
/// @brief Destroy the instance and free all associated memory
////////////////////////////////////////////////////////////////////////////////

        ~ParserWrapper ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Parse the query passed 
////////////////////////////////////////////////////////////////////////////////

        bool parse ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Get a parse error that may have occurred
////////////////////////////////////////////////////////////////////////////////

        ParseError* getParseError ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Get the type of the query
////////////////////////////////////////////////////////////////////////////////

        QL_ast_query_type_e getQueryType ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Optimizes the query parts
////////////////////////////////////////////////////////////////////////////////
        
        void optimize ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Create a select clause
////////////////////////////////////////////////////////////////////////////////

        TRI_qry_select_t* getSelect ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Create joins
////////////////////////////////////////////////////////////////////////////////
 
        TRI_select_join_t* getJoins ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Create a where clause
////////////////////////////////////////////////////////////////////////////////

        TRI_qry_where_t* getWhere ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Create an order clause
////////////////////////////////////////////////////////////////////////////////

        TRI_qry_order_t* getOrder ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Get the skip value
////////////////////////////////////////////////////////////////////////////////

        TRI_voc_size_t getSkip ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Get the limit value
////////////////////////////////////////////////////////////////////////////////

        TRI_voc_ssize_t getLimit ();

      private:
        
////////////////////////////////////////////////////////////////////////////////
/// @brief Register the parse error set by the parser
////////////////////////////////////////////////////////////////////////////////

        void setParseError ();

////////////////////////////////////////////////////////////////////////////////
/// @brief Vocbase
////////////////////////////////////////////////////////////////////////////////

        const TRI_vocbase_t* _vocbase;

////////////////////////////////////////////////////////////////////////////////
/// @brief Query string
////////////////////////////////////////////////////////////////////////////////

        const char* _query;
 
////////////////////////////////////////////////////////////////////////////////
/// @brief Parser context. This is a struct that is used extensively by the
/// parser. It contains a pointer to the flex lexer, a pointer to the query's
/// AST root nodes and state information for memory management (GC) 
////////////////////////////////////////////////////////////////////////////////

        QL_parser_context_t* _context;

////////////////////////////////////////////////////////////////////////////////
/// @brief Pointer to a parse error
///
/// The parse error object is automatically created during parsing if a parse
/// error occurs. It will be freed automatically when the parser is destroyed.
////////////////////////////////////////////////////////////////////////////////

        ParseError* _parseError;

////////////////////////////////////////////////////////////////////////////////
/// @brief Flag if parsing has already taken place
///
/// Using this flag duplicate parsing and all of its issues can be avoided
////////////////////////////////////////////////////////////////////////////////

        bool _isParsed;

////////////////////////////////////////////////////////////////////////////////
/// @brief Flag if query is already optimized
///
/// Using this flag optimization is only performed once
////////////////////////////////////////////////////////////////////////////////

        bool _isOptimized;
    }; 

  }
}

///////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////

#endif

// Local Variables:
// mode: outline-minor
// outline-regexp: "^\\(/// @brief\\|/// {@inheritDoc}\\|/// @addtogroup\\|// --SECTION--\\|/// @\\}\\)"
// End:
