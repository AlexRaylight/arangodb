////////////////////////////////////////////////////////////////////////////////
/// @brief parser context for flex-based query scanner
///
/// @file
///
/// DISCLAIMER
///
/// Copyright 2010-2012 triagens GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is triAGENS GmbH, Cologne, Germany
///
/// @author Jan Steemann
/// @author Copyright 2012, triagens GmbH, Cologne, Germany
////////////////////////////////////////////////////////////////////////////////

#ifndef TRIAGENS_DURHAM_QL_PARSERCONTEXT
#define TRIAGENS_DURHAM_QL_PARSERCONTEXT

#include <BasicsC/common.h>
#include <BasicsC/strings.h>
#include <BasicsC/vector.h>

#include <stdarg.h>

#include "QL/parser.h"
#include "QL/error.h"
#include "QL/ast-node.h"
#include "QL/ast-query.h"

#ifdef __cplusplus
extern "C" {
#endif

////////////////////////////////////////////////////////////////////////////////
/// @addtogroup QL
/// @{
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/// @brief Parser stages
////////////////////////////////////////////////////////////////////////////////

typedef enum {
  STAGE_UNDEFINED  = 0,

  STAGE_PARSE,
  STAGE_POST_PARSE 
}
QL_parse_stage_e;

////////////////////////////////////////////////////////////////////////////////
/// @brief lexer error state container
///
/// This struct keeps track of parsing errors that occur during lexing and 
/// parsing.
/// It contains the position (line / column) where the error occurred plus a
/// pointer to the error message as generated by bison / flex.
////////////////////////////////////////////////////////////////////////////////

typedef struct QL_error_state_s {
  QL_error_type_e _code;
  int _line;
  int _column;
  char *_message;
} 
QL_error_state_t;

////////////////////////////////////////////////////////////////////////////////
/// @brief lexer state
///
/// This struct contains the current lexer / scanner state. It contains 
/// positioning information (pointer into query string, remaining length)
/// because flex processes strings in chunks of 8k by default.
/// Additionally it contains any error information in case a parse error occurs.
///
/// Each lexer instance will have its own struct instance to support reentrancy.
////////////////////////////////////////////////////////////////////////////////

typedef struct QL_lex_state_s {
  int _length;
  char *_buffer;
  QL_error_state_t _errorState;
} 
QL_lex_state_t;

////////////////////////////////////////////////////////////////////////////////
/// @brief parser context
///
/// This struct contains the complete context for processing queries.
/// It contains a lexer / scanner instance, the lexer state and some vectors 
/// that contain locations of allocated memory. This is especially important
/// because in case of parse errors, bison / flex will not automatically free
/// allocated memory. This has to be done manually, and that is what the vectors
/// are used for. There is a vector for AST nodes and a vector for strings
/// (used to keep track of string literals used in the query). There are also
/// two vectors to keep track of list elements (arrays / objects) in queries.
///
/// Each parser instance will have its own struct instance to support reentrancy.
////////////////////////////////////////////////////////////////////////////////

typedef struct QL_parser_context_s {
  void                  *_scanner;  
  QL_parse_stage_e      _stage; 
  QL_lex_state_t        _lexState;        
  QL_ast_query_t        *_query;
  TRI_vector_pointer_t  _nodes;       // memory locations of allocated AST node
  TRI_vector_pointer_t  _strings;     // memory locations of allocated strings
  TRI_vector_pointer_t  _listHeads;   // start of lists
  TRI_vector_pointer_t  _listTails;   // end of lists
} 
QL_parser_context_t;

////////////////////////////////////////////////////////////////////////////////
/// @brief Validation function for collection names
////////////////////////////////////////////////////////////////////////////////

typedef bool(*QL_parser_validate_func) (QL_ast_query_t*, const char*, const size_t);

////////////////////////////////////////////////////////////////////////////////
/// @brief Forward declaration for parse function as generated by flex/bison
////////////////////////////////////////////////////////////////////////////////

int QLparse (QL_parser_context_t*);
int QLlex_destroy (void *);
void QLset_extra (QL_parser_context_t*, void*);
int QLlex_init (void**);
int QLget_lineno (void*);
int QLget_column (void*);

////////////////////////////////////////////////////////////////////////////////
/// @brief initializes the parser context for a query
/// 
/// This function must be called before starting to parse any query. It will
/// reset the context, set the location pointers and set up memory structures
/// for later garbage collection
////////////////////////////////////////////////////////////////////////////////

bool QLParseInit (const TRI_vocbase_t*, QL_parser_context_t*, const char*);

////////////////////////////////////////////////////////////////////////////////
/// @brief free all memory allocated in context of a query
///
/// This function must be called when processing a query is finished. It will
/// free all memory that was allocated when parsing a query and setting up the
/// query's AST. It will also de-allocate all nodes in the AST so that they
/// cannot be used anymore after this function is called.
////////////////////////////////////////////////////////////////////////////////

void QLParseFree (QL_parser_context_t*);

////////////////////////////////////////////////////////////////////////////////
/// @brief keep track of an allocated ast node
///
/// Register a created node's memory location for later garbage collection
////////////////////////////////////////////////////////////////////////////////

void QLParseRegisterNode (QL_parser_context_t*, QL_ast_node_t*);

////////////////////////////////////////////////////////////////////////////////
/// @brief free an ast node
///
/// Free one node
////////////////////////////////////////////////////////////////////////////////

void QLParseFreeNode (QL_ast_node_t*);

////////////////////////////////////////////////////////////////////////////////
/// @brief copies a string and keeps track of its memory location in a vector
///
/// This mimics TRI_DuplicateString (@ref TRI_DuplicateString) but also keeps
/// track of the strings memory location for later garbage collection.
////////////////////////////////////////////////////////////////////////////////

char* QLParseAllocString (QL_parser_context_t*, const char*);

////////////////////////////////////////////////////////////////////////////////
/// @brief copies a string part and keeps track of its memory location in a vector
///
/// This mimics TRI_DuplicateString2 (@ref TRI_DuplicateString2) but also keeps
/// track of the strings memory location for later garbage collection.
////////////////////////////////////////////////////////////////////////////////

char* QLParseAllocString2 (QL_parser_context_t*,const char*, const size_t);

////////////////////////////////////////////////////////////////////////////////
/// @brief keep track of an allocated string
///
/// Register a strings memory location for later garbage collection
////////////////////////////////////////////////////////////////////////////////

char* QLParseRegisterString (QL_parser_context_t*, const char*);

////////////////////////////////////////////////////////////////////////////////
/// @brief free a string
///
/// Free memory that was allocated for a string
////////////////////////////////////////////////////////////////////////////////

void QLParseFreeString (char*);

////////////////////////////////////////////////////////////////////////////////
/// @brief create a new node for the ast
///
/// Create a new AST node of the given type (@ref QL_ast_node_type_e)
////////////////////////////////////////////////////////////////////////////////

QL_ast_node_t* QLAstNodeCreate (QL_parser_context_t*, const QL_ast_node_type_e); 

////////////////////////////////////////////////////////////////////////////////
/// @brief open a new context layer for the parser
///
/// Layers are currently necessary to keep track of non-hierarchical lists
/// (arrays, objects) in the parser.
////////////////////////////////////////////////////////////////////////////////

void QLParseContextPush (QL_parser_context_t*, QL_ast_node_t*);

////////////////////////////////////////////////////////////////////////////////
/// @brief close the current context layer of the parser and return it
////////////////////////////////////////////////////////////////////////////////

QL_ast_node_t* QLParseContextPop (QL_parser_context_t*);

////////////////////////////////////////////////////////////////////////////////
/// @brief add an element to the current parsing context
////////////////////////////////////////////////////////////////////////////////

void QLParseContextAddElement (QL_parser_context_t*, QL_ast_node_t*);

////////////////////////////////////////////////////////////////////////////////
/// @brief pop the current parse context from the stack into the rhs element
////////////////////////////////////////////////////////////////////////////////

void QLPopIntoRhs (QL_ast_node_t*, QL_parser_context_t*);

////////////////////////////////////////////////////////////////////////////////
/// @brief Register a parse error
////////////////////////////////////////////////////////////////////////////////

void QLParseRegisterParseError (QL_parser_context_t*, const QL_error_type_e, ...);

////////////////////////////////////////////////////////////////////////////////
/// @brief Register a post-parse error
////////////////////////////////////////////////////////////////////////////////

void QLParseRegisterPostParseError (QL_parser_context_t*, const int32_t,
                                    const int32_t, const QL_error_type_e, ...);

////////////////////////////////////////////////////////////////////////////////
/// @brief Validate a collection name
///
/// Currently, a collection name must consist of the letters A-Z or a-z only
/// Its length must not exceed QL_QUERY_NAME_LEN chars.
////////////////////////////////////////////////////////////////////////////////

bool QLParseValidateCollectionName (const char*);

////////////////////////////////////////////////////////////////////////////////
/// @brief Validate a collection alias
///
/// Currently, a collection name must consist of the letters A-Z or a-z only
/// Its length must not exceed QL_QUERY_NAME_LEN chars.
////////////////////////////////////////////////////////////////////////////////

bool QLParseValidateCollectionAlias (const char*);

////////////////////////////////////////////////////////////////////////////////
/// @brief Validate the collections used in a query part
///
/// Currently validates if all used collection names in the query part are 
/// actually declared in the query's from clause.
////////////////////////////////////////////////////////////////////////////////

bool QLParseValidateCollections (QL_parser_context_t*, 
                                 QL_ast_node_t*,
                                 QL_parser_validate_func,
                                 size_t*);

////////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#endif

// Local Variables:
// mode: outline-minor
// outline-regexp: "^\\(/// @brief\\|/// {@inheritDoc}\\|/// @addtogroup\\|// --SECTION--\\|/// @\\}\\)"
// End:

