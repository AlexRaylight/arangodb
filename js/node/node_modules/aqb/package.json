{
  "name": "aqb",
  "license": "APACHE2_0",
  "version": "1.1.0",
  "description": "ArangoDB AQL query builder.",
  "keywords": [
    "arangodb",
    "aql",
    "nosql",
    "query"
  ],
  "author": {
    "name": "Alan Plum",
    "email": "me@pluma.io",
    "url": "https://www.arangodb.org"
  },
  "dependencies": {},
  "devDependencies": {
    "expect.js": "^0.3.1",
    "mocha": "^1.21.4"
  },
  "engine": "node >= 0.8.0",
  "bugs": {
    "url": "https://github.com/arangodb/aqbjs/issues"
  },
  "scripts": {
    "test": "mocha --growl -R spec test/**/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/arangodb/aqbjs.git"
  },
  "main": "index.js",
  "readme": "# ArangoDB Query Builder\n\nThe query builder allows constructing complex AQL queries with a pure JavaScript fluid API.\n\n```js\n// in arangosh\nvar db = require('org/arangodb').db;\nvar qb = require('aqb');\nconsole.log(db._query(qb.for('x').in('1..5').return('x').toAQL()).toArray()); // [1, 2, 3, 4, 5]\n```\n\n## API\n\n### AQL Types\n\nIf raw JavaScript values are passed to AQL statements, they will be wrapped in a matching AQL type automatically.\n\nJavaScript strings wrapped in quotation marks will be wrapped in AQL strings, all other JavaScript strings will be wrapped as simple references (see below) and throw an *AQLError* if they are not well-formed.\n\n#### Boolean\n\nWraps the given value as an AQL Boolean literal.\n\n`qb.bool(value)`\n\nIf the value is truthy, it will be converted to the AQL Boolean *true*, otherwise it will be converted to the AQL Boolean *false*.\n\nIf the value is already an AQL Boolean, its own value will be wrapped instead.\n\n#### Number\n\nWraps the given value as an AQL Number literal.\n\n`qb.num(value)`\n\nIf the value is not a JavaScript Number, it will be converted first.\n\nIf the value does not represent a finite number, an *AQLError* will be thrown.\n\nIf the value is already an AQL Number or AQL Integer, its own value will be wrapped instead.\n\n#### Integer\n\nWraps the given value as an AQL Integer literal.\n\n`qb.int(value)`\n\nIf the value is not a JavaScript Number, it will be converted first.\n\nIf the value does not represent a finite integer, an *AQLError* will be thrown.\n\nIf the value is already an AQL Number or AQL Integer, its own value will be wrapped instead.\n\n*Alias:* `qb.int_(value)`\n\n#### String\n\nWraps the given value as an AQL String literal.\n\n`qb.str(value)`\n\nIf the value is not a JavaScript String, it will be converted first.\n\nIf the value is already an AQL String, its own value will be wrapped instead.\n\nIf the value is an object with a *toAQL* method, the result of calling that method will be wrapped instead.\n\n#### List\n\nWraps the given value as an AQL List (Array) literal.\n\n`qb.list(value)`\n\nIf the value is not a JavaScript Array, an *AQLError* will be thrown.\n\nIf the value is already an AQL List, its own value will be wrapped instead.\n\nAny list elements that are not already AQL values will be converted automatically.\n\n#### Object\n\nWraps the given value as an AQL Object literal.\n\n`qb.obj(value)`\n\nIf the value is not a JavaScript Object, an *AQLError* will be thrown.\n\nIf the value is already an AQL List, its own value will be wrapped instead.\n\nAny property values that are not already AQL values will be converted automatically.\n\n#### Simple Reference\n\nWraps a given value in an AQL Simple Reference.\n\n`qb.ref(value)`\n\nIf the value is not a JavaScript string or not a well-formed simple reference, an *AQLError* will be thrown.\n\nIf the value is already an AQL Simple Reference, its value is wrapped instead.\n\n*Examples*\n\nValid values:\n\n* `foo`\n* `foo.bar`\n* `foo[*].bar`\n* `foo.bar.QUX`\n* `_foo._bar._qux`\n* `foo1.bar2`\n\nInvalid values:\n\n* `1foo`\n* `föö`\n* `foo bar`\n* `foo-bar`\n* `foo[bar]`\n\n### AQL Expressions\n\n#### Range\n\nCreates a range expression from the given values.\n\n`qb.range(value1, value2)` -> `value1..value2`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n#### Property Access\n\nCreates a property access expression from the given values.\n\n`qb.get(obj, key)` -> `obj[key]`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n#### Raw Expression\n\nWraps a given value in a raw AQL expression.\n\n`qb.expr(value)`\n\nIf the value is already an AQL Raw Expression, its value is wrapped instead.\n\n**Warning:** Whenever possible, you should use one of the other methods or a combination thereof instead of using a raw expression. Raw expressions allow passing arbitrary strings into your AQL and thus will open you to AQL injection attacks if you are passing in untrusted user input.\n\n### AQL Operations\n\n#### Boolean And\n\nCreates an \"and\" operation from the given values.\n\n`qb.and(a, b)` -> `(a && b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\nThis function can take any number of arguments.\n\n*Examples*\n\n`qb.and(a, b, c, d, e, f)` -> `(a && b && c && d && e && f)`\n\n#### Boolean Or\n\nCreates an \"or\" operation from the given values.\n\n`qb.or(a, b)` -> `(a || b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\nThis function can take any number of arguments.\n\n*Examples*\n\n`qb.or(a, b, c, d, e, f)` -> `(a || b || c || d || e || f)`\n\n#### Addition\n\nCreates an addition operation from the given values.\n\n`qb.add(a, b)` -> `(a + b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\nThis function can take any number of arguments.\n\n*Aliases:* `qb.plus(a, b)`\n\n*Examples*\n\n`qb.add(a, b, c, d, e, f)` -> `(a + b + c + d + e + f)`\n\n#### Subtraction\n\nCreates a subtraction operation from the given values.\n\n`qb.sub(a, b)` -> `(a - b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\nThis function can take any number of arguments.\n\n*Aliases:* `qb.minus(a, b)`\n\n*Examples*\n\n`qb.sub(a, b, c, d, e, f)` -> `(a - b - c - d - e - f)`\n\n#### Multiplication\n\nCreates a multiplication operation from the given values.\n\n`qb.mul(a, b)` -> `(a * b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\nThis function can take any number of arguments.\n\n*Aliases:* `qb.times(a, b)`\n\n*Examples*\n\n`qb.mul(a, b, c, d, e, f)` -> `(a * b * c * d * e * f)`\n\n#### Division\n\nCreates a division operation from the given values.\n\n`qb.div(a, b)` -> `(a / b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\nThis function can take any number of arguments.\n\n*Examples*\n\n`qb.div(a, b, c, d, e, f)` -> `(a / b / c / d / e / f)`\n\n#### Modulus\n\nCreates a modulus operation from the given values.\n\n`qb.mod(a, b)` -> `(a % b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\nThis function can take any number of arguments.\n\n*Examples*\n\n`qb.mod(a, b, c, d, e, f)` -> `(a % b % c % d % e % f)`\n\n#### Equality\n\nCreates an equality comparison from the given values.\n\n`qb.eq(a, b)` -> `(a == b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n#### Inequality\n\nCreates an inequality comparison from the given values.\n\n`qb.neq(a, b)` -> `(a != b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n#### Greater Than\n\nCreates a greater-than comparison from the given values.\n\n`qb.gt(a, b)` -> `(a > b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n#### Greater Than Or Equal To\n\nCreates a greater-than-or-equal-to comparison from the given values.\n\n`qb.gte(a, b)` -> `(a >= b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n#### Less Than\n\nCreates a less-than comparison from the given values.\n\n`qb.lt(a, b)` -> `(a < b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n#### Less Than Or Equal To\n\nCreates a less-than-or-equal-to comparison from the given values.\n\n`qb.lte(a, b)` -> `(a <= b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n#### Contains\n\nCreates an \"in\" comparison from the given values.\n\n`qb.in(a, b)` -> `(a in b)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n*Aliases:* `qb.in_(a, b)`\n\n#### Negation\n\nCreates a negation from the given value.\n\n`qb.not(a)` -> `!(a)`\n\nIf the value is not already an AQL value, it will be converted automatically.\n\n#### Negative Value\n\nCreates a negative value expression from the given value.\n\n`qb.neg(a)` -> `-(a)`\n\nIf the value is not already an AQL value, it will be converted automatically.\n\n#### Ternary (if / else)\n\nCreates a ternary expression from the given values.\n\n`qb.if(condition, then, otherwise)` -> `(condition ? then : otherwise)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\n*Aliases:* `qb.if_(condition, then, otherwise)`\n\n#### Function Call\n\nCreates a function call for the given name and arguments.\n\n`qb.fn(name)(args…)`\n\nIf the values are not already AQL values, they will be converted automatically.\n\nFor built-in functions, methods with the relevant function name are already provided by the query builder.\n\n*Examples*\n\n* `qb.fn('MY::USER::FUNC')(1, 2, 3)` -> `MY::USER::FUNC(1, 2, 3)`\n* `qb.fn('hello')()` -> `hello()`\n* `qb.RANDOM()` -> `RANDOM()`\n* `qb.FLOOR(qb.div(5, 2))` -> `FLOOR((5 / 2))`\n\n### AQL Statements\n\nIn addition to the methods documented above, the query builder provides all methods of *PartialStatement* objects.\n\nAQL *Statement* objects have a method *toAQL()* which returns their AQL representation as a JavaScript string.\n\n*Examples*\n\n```\nqb.for('doc').in('my_collection').return('doc._key').toAQL()\n// -> FOR doc IN my_collection RETURN doc._key\n```\n\n#### FOR expression IN collection\n\n`PartialStatement::for(expression).in(collection) : Statement`\n\n*Alias:* `for_(expression).in_(collection)`\n\n#### LET varname = expression\n\n`PartialStatement::let(varname, expression) : Statement`\n\n*Alias:* `let_(varname, expression)`\n\n#### LET var1 = expr1, var2 = expr2, …, varn = exprn\n\n`PartialStatement::let(definitions) : Statement`\n\n*Alias:* `let_(definitions)`\n\n#### FILTER expression\n\n`PartialStatement::filter(expression) : Statement`\n\n#### COLLECT varname = expression\n\n`PartialStatement::collect(varname, expression) : Statement`\n\n#### COLLECT varname1 = expression INTO varname2\n\n`PartialStatement::collect(varname1, expression).into(varname2) : Statement`\n\n#### COLLECT var1 = expr1, var2 = expr2, …, varn = exprn\n\n`PartialStatement::collect(definitions) : Statement`\n\n#### COLLECT var1 = expr1, var2 = expr2, …, varn = exprn INTO varname\n\n`PartialStatement::collect(definitions).into(varname) : Statement`\n\n#### SORT args…\n\n`PartialStatement::sort(args…) : Statement`\n\n#### LIMIT offset, count\n\n`PartialStatement::limit([offset,] count) : Statement`\n\n#### RETURN expression\n\n`PartialStatement::return(expression) : Statement`\n\n*Alias:* `return_(expression)`\n\n#### REMOVE expression IN collection\n\n`PartialStatement::remove(expression).in(collection) : RemoveExpression`\n\n*Aliases:*\n\n* `remove(expression).in_(collection)`\n* `remove(expression).into(collection)`\n\n#### REMOVE … OPTIONS options\n\n`RemoveExpression::options(options) : Statement`\n\n#### INSERT expression INTO collection\n\n`PartialStatement::insert(expression).into(collection) : InsertExpression`\n\n*Aliases:*\n\n* `insert(expression).in(collection)`\n* `insert(expression).in_(collection)`\n\n#### INSERT … OPTIONS options\n\n`InsertExpression::options(options) : Statement`\n\n#### UPDATE expression1 WITH expression2 IN collection\n\n`PartialStatement::update(expression1).with(expression2).in(collection) : UpdateExpression`\n\n*Aliases:*\n\n* `update(expression1).with(expression2).in_(collection)`\n* `update(expression1).with(expression2).into(collection)`\n* `update(expression1).with_(expression2).in(collection)`\n* `update(expression1).with_(expression2).in_(collection)`\n* `update(expression1).with_(expression2).into(collection)`\n\n#### UPDATE expression IN collection\n\n`PartialStatement::update(expression).in(collection) : UpdateExpression`\n\n*Aliases:*\n\n* `update(expression).in_(collection)`\n* `update(expression).into(collection)`\n\n#### UPDATE … OPTIONS options\n\n`UpdateExpression::options(options) : Statement`\n\n#### REPLACE expression1 WITH expression2 IN collection\n\n`PartialStatement::replace(expression1).with(expression2).in(collection) : ReplaceExpression`\n\n*Aliases:*\n\n* `replace(expression1).with(expression2).in_(collection)`\n* `replace(expression1).with(expression2).into(collection)`\n* `replace(expression1).with_(expression2).in(collection)`\n* `replace(expression1).with_(expression2).in_(collection)`\n* `replace(expression1).with_(expression2).into(collection)`\n\n#### REPLACE expression IN collection\n\n`PartialStatement::replace(expression).in(collection) : ReplaceExpression`\n\n*Aliases:*\n\n* `replace(expression).in_(collection)`\n* `replace(expression).into(collection)`\n\n#### REPLACE … OPTIONS options\n\n`ReplaceExpression::options(options) : Statement`\n",
  "readmeFilename": "README.md",
  "gitHead": "7eb382e2cb293454a2c6d22cb8e02f74cf0c4260",
  "homepage": "https://github.com/arangodb/aqbjs",
  "_id": "aqb@1.1.0",
  "_shasum": "9a5130c6dfe24d73256a88e576a02469deaabe35",
  "_from": "aqb@"
}
