<html><head><title>ArangoDB Manual</title> <style media="screen" type="text/css" style="display:none">body{background-color:white;font:13px Helvetica,arial,freesans,clean,sans-serif;line-height:1.4;color:#333;}#access{font-size:16px;margin-left:12px;display:block;margin-left:10px;margin-right:10px;background-color:#F3F1EE!important;}#access a{border-right:1px solid #DBDEDF;color:#A49F96;display:block;line-height:38px;padding:0 10px;text-decoration:none;}#navigation ul{text-transform:uppercase;list-style:none;margin:0;}#navigation li{float:left;position:relative;}#container{width:920px;margin:0 auto;}a{color:#4183C4;text-decoration:none;}.contents h2{font-size:24px;border-bottom:1px solid #CCC;color:black;}.contents h1{font-size:33px;border-bottom:1px solid #CCC;color:black;}.clearfix:after{content:".";display:block;clear:both;font-size:0;height:0;visibility:hidden;}/**/ *:first-child+html .clearfix{min-height:0;}/**/ * html .clearfix{height:1%;}</style></head><body><div id="container"><img src="images/logo_arangodb.png" width="397" height="67" alt="ArangoDB"><div id="access" role="navigation"><div id="navigation"><ul id="menu-ahome" class="menu"><li><a href="Home.html">Table of contents</a></li> <li><a href="http://www.arangodb.org">ArangoDB homepage</a></li></ul></div><div class="clearfix"></div></div><div>
<!-- Generated by Doxygen 1.7.3 -->
</div>
<div class="header">
  <div class="headertitle">
<h1>Simple Queries </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>Simple queries can be used if the query condition is straight forward, i.e., a document reference, all documents, a query-by-example, or a simple geo query. In a simple query you can specify exactly one collection and one query criteria. In the following sections we describe the JavaScript shell interface for simple queries, which you can use within the ArangoDB shell and within actions and transactions. For other languages see the corresponding language API documentation.</p>
<p>If a query returns a cursor, then you can use <code>hasNext</code> and <code>next</code> to iterate over the result set or <code>toArray</code> to convert it to an array.</p>
<p>If the number of query results is expected to be big, it is possible to limit the amount of documents transferred between the server and the client to a specific value. This value is called <code>batchSize</code>. The <code>batchSize</code> can optionally be set before or when a simple query is executed. If the server has more documents than should be returned in a single batch, the server will set the <code>hasMore</code> attribute in the result. It will also return the id of the server-side cursor in the <code>id</code> attribute in the result. This id can be used with the cursor API to fetch any outstanding results from the server and dispose the server-side cursor afterwards.</p>
<p>The initial <code>batchSize</code> value can be set using the <code>setBatchSize</code> method that is available for each type of simple query, or when the simple query is executed using its <code>execute</code> method. If no <code>batchSize</code> value is specified, the server will pick a reasonable default value.</p>
<hr/>
<ul>
<li>
<a class="el" href="SimpleQueries.html">Simple Queries</a> <ul>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueriesQueries">Queries</a> <ul>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryAll">collection.all</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryByExample">collection.byExample</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryFirstExample">collection.firstExample</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryRange">collection.range</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryCollectionCount">collection.count</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryToArray">collection.toArray</a> </li>
</ul>
</li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueriesGeoQueries">Geo Queries</a> <ul>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryNear">collection.near</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryWithin">collection.within</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryGeo">collection.geo</a> </li>
</ul>
</li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueriesPagination">Pagination</a> <ul>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryLimit">query.limit</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQuerySkip">query.skip</a> </li>
</ul>
</li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueriesCursor">Sequential Access and Cursors</a> <ul>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryHasNext">query.hasNext</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryNext">query.next</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQuerySetBatchSize">query.setBatchSize</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryGetBatchSize">query.getBatchSize</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryExecute">query.execute</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryDispose">query.dispose</a> </li>
<li>
<a class="el" href="SimpleQueries.html#SimpleQueryCount">query.count</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
<hr/>
 <h2><a class="anchor" id="SimpleQueriesQueries"></a>
Queries</h2>
<p><a class="anchor" id="SimpleQueryAll"></a> <hr/>
<code><b>all()</b></code><hr/>
 Selects all documents of a collection and returns a cursor. You can use <code>toArray</code>, <code>next</code>, or <code>hasNext</code> to access the result. The result can be limited using the <code>skip</code> and <code>limit</code> operator.</p>
<p><b>Examples</b><br/>
</p>
<p>Use <code>toArray</code> to get all documents at once:</p>
<div class="fragment"><pre class="fragment">arango&gt; db.five.all().toArray();
[ { _id : 159896:1798296, _rev : 1798296, doc : 3 },
  { _id : 159896:1732760, _rev : 1732760, doc : 2 },
  { _id : 159896:1863832, _rev : 1863832, doc : 4 },
  { _id : 159896:1667224, _rev : 1667224, doc : 1 },
  { _id : 159896:1929368, _rev : 1929368, doc : 5 } ]
</pre></div><p>Use <code>next</code> to loop over all documents:</p>
<div class="fragment"><pre class="fragment">arango&gt; var a = db.five.all();
arango&gt; while (a.hasNext()) print(a.next());
{ _id : 159896:1798296, _rev : 1798296, doc : 3 }
{ _id : 159896:1732760, _rev : 1732760, doc : 2 }
{ _id : 159896:1863832, _rev : 1863832, doc : 4 }
{ _id : 159896:1667224, _rev : 1667224, doc : 1 }
{ _id : 159896:1929368, _rev : 1929368, doc : 5 }
</pre></div> <p><a class="anchor" id="SimpleQueryByExample"></a> <hr/>
<code><b><em>collection</em>.byExample(<em>example</em>)</b></code><hr/>
 Selects all documents of a collection that match the specified example and returns a cursor.</p>
<p>You can use <code>toArray</code>, <code>next</code>, or <code>hasNext</code> to access the result. The result can be limited using the <code>skip</code> and <code>limit</code> operator.</p>
<p>An attribute name of the form <code>a.b</code> is interpreted as attribute path, not as attribute. If you use</p>
<p><code>{ a : { c : 1 } }</code></p>
<p>as example, then you will find all documents, such that the attribute <code>a</code> contains a document of the form <code>{c : 1 }</code>. E.g., the document</p>
<p><code>{ a : { c : 1 }, b : 1 }</code></p>
<p>will match, but the document</p>
<p><code>{ a : { c : 1, b : 1 } }</code></p>
<p>will not.</p>
<p>However, if you use</p>
<p><code>{ a.c : 1 }</code>,</p>
<p>then you will find all documents, which contain a sub-document in <code>a</code> that has an attribute <code>c</code> of value <code>1</code>. E.g., both documents</p>
<p><code>{ a : { c : 1 }, b : 1 }</code> and</p>
<p><code>{ a : { c : 1, b : 1 } }</code></p>
<p>will match.</p>
<hr/>
<code><b><em>collection</em>.byExample(<em>path1</em>, <em>value1</em>, ...)</b></code><hr/>
 As alternative you can supply a list of paths and values.</p>
<p><b>Examples</b><br/>
</p>
<p>Use <code>toArray</code> to get all documents at once:</p>
<div class="fragment"><pre class="fragment">arango&gt; db.users.all().toArray();
[ { "_id" : "553063885:554702285", "_rev" : 554702285, "id" : 323, "name" : "Peter" }, 
  { "_id" : "553063885:554636749", "_rev" : 554636749, "id" : 535, "name" : "Peter" }, 
  { "_id" : "553063885:554833357", "_rev" : 554833357, "id" : 25, "name" : "Vladimir" } ]

arango&gt; db.users.byExample({ "id" : 323 }).toArray();
[ { "id" : 323, "name" : "Peter", "_id" : "553063885:554702285" } ]

arango&gt; db.users.byExample({ "name" : "Peter" }).toArray();
[ { "id" : 323, "name" : "Peter", "_id" : "553063885:554702285" }, 
  { "id" : 535, "name" : "Peter", "_id" : "553063885:554636749" } ]

arango&gt; db.users.byExample({ "name" : "Peter", "id" : 535 }).toArray();
[ { "id" : 535, "name" : "Peter", "_id" : "553063885:554636749" } ]
</pre></div> <p>Use <code>next</code> to loop over all documents:</p>
<div class="fragment"><pre class="fragment">arango&gt; var a = db.users.select( {"name" : "Peter" } );
arango&gt; while (a.hasNext()) print(a.next());
{ "id" : 323, "name" : "Peter", "_id" : "553063885:554702285" } 
{ "id" : 535, "name" : "Peter", "_id" : "553063885:554636749" }
</pre></div>  <p><a class="anchor" id="SimpleQueryFirstExample"></a> <hr/>
<code><b><em>collection</em>.firstExample(<em>example</em>)</b></code><hr/>
 Returns the a document of a collection that match the specified example or <code>null</code>. The example must be specified as paths and values. See <code>byExample</code> for details.</p>
<hr/>
<code><b><em>collection</em>.firstExample(<em>path1</em>, <em>value1</em>, ...)</b></code><hr/>
 As alternative you can supply a list of paths and values.</p>
<p><b>Examples</b><br/>
</p>
<div class="fragment"><pre class="fragment">arango&gt; db.users.firstExample("name", 1237);
{ "_id" : "100225/83049373", "_rev" : 83049373, "name" : 1237 }
</pre></div>  <p><a class="anchor" id="SimpleQueryRange"></a> <hr/>
<code><b><em>collection</em>.range(<em>attribute</em>, <em>left</em>, <em>right</em>)</b></code><hr/>
 Selects all documents of a collection such that the <em>attribute</em> is greater or equal than <em>left</em> and strictly less than <em>right</em>.</p>
<p>You can use <code>toArray</code>, <code>next</code>, or <code>hasNext</code> to access the result. The result can be limited using the <code>skip</code> and <code>limit</code> operator.</p>
<p>An attribute name of the form <code>a.b</code> is interpreted as attribute path, not as attribute.</p>
<p><b>Examples</b><br/>
</p>
<p>Use <code>toArray</code> to get all documents at once:</p>
<div class="fragment"><pre class="fragment">arangod&gt; l = db.skip.range("age", 10, 13).toArray();
[
  { "_id" : "2097590/4260278", "_rev" : 4260278, "age" : 10 },
  { "_id" : "2097590/4325814", "_rev" : 4325814, "age" : 11 }, 
  { "_id" : "2097590/4391350", "_rev" : 4391350, "age" : 12 }
]
</pre></div>  <p><a class="anchor" id="SimpleQueryCollectionCount"></a> <hr/>
<code><b><em>collection</em>.count()</b></code><hr/>
 Returns the number of living documents in the collection.</p>
<p><b>Examples</b><br/>
</p>
<div class="fragment"><pre class="fragment">arango&gt; db.users.count();
10001
</pre></div> <p><a class="anchor" id="SimpleQueryToArray"></a> <hr/>
<code><b><em>collection</em>.toArray()</b></code><hr/>
 Converts the collection into an array of documents. Never use this call in a production environment. </p>
<h2><a class="anchor" id="SimpleQueriesGeoQueries"></a>
Geo Queries</h2>
<p>The ArangoDB allows to select documents based on geographic coordinates. In order for this to work, a geo-spatial index must be defined. This index will use a very elaborate algorithm to lookup neighbors that is a magnitude faster than a simple R* index.</p>
<p>In general a geo coordinate is a pair of latitude and longitude. This can either be an list with two elements like <code>[-10, +30]</code> (latitude first, followed by longitude) or an object like <code>{lon: -10, lat: +30}</code>. In order to find all documents within a given radius around a coordinate use the <code>within</code> operator. In order to find all documents near a given document use the <code>near</code> operator.</p>
<p>It is possible to define more than one geo-spatial index per collection. In this case you must give a hint using the <code>geo</code> operator which of indexes should be used in a query.</p>
<p><a class="anchor" id="SimpleQueryNear"></a> <hr/>
<code><b><em>collection</em>.near(<em>latitude</em>, <em>longitude</em>)</b></code><hr/>
<p>The default will find at most 100 documents near the coordinate (<em>latitude</em>, <em>longitude</em>). The returned list is sorted according to the distance, with the nearest document coming first. If there are near documents of equal distance, documents are chosen randomly from this set until the limit is reached. It is possible to change the limit using the <em>limit</em> operator.</p>
<p>In order to use the <code>near</code> operator, a geo index must be defined for the collection. This index also defines which attribute holds the coordinates for the document. If you have more then one geo-spatial index, you can use the <code>geo</code> operator to select a particular index.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><code>near</code> does not support negative skips. However, you can still use <code>limit</code> followed to <code>skip</code>.</dd></dl>
<hr/>
<code><b><em>collection</em>.near(<em>latitude</em>, <em>longitude</em>).limit(<em>limit</em>)</b></code><hr/>
<p>Limits the result to <em>limit</em> documents instead of the default 100.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Unlike with multiple explicit limits, <em>limit</em> will raise the implicit default limit imposed by <code>within</code>.</dd></dl>
<hr/>
<code><b><em>collection</em>.near(<em>latitude</em>, <em>longitude</em>).distance()</b></code><hr/>
<p>This will add an attribute <code>distance</code> to all documents returned, which contains the distance between the given point and the document in meter.</p>
<hr/>
<code><b><em>collection</em>.near(<em>latitude</em>, <em>longitude</em>).distance(<em>name</em>)</b></code><hr/>
<p>This will add an attribute <em>name</em> to all documents returned, which contains the distance between the given point and the document in meter.</p>
<p><b>Examples</b><br/>
</p>
<p>To get the nearst two locations:</p>
<div class="fragment"><pre class="fragment">arango&gt; db.geo.near(0,0).limit(2).toArray();
[ { _id : 131840:24773376, _rev : 24773376, name : Name/0/0, loc : [ 0, 0 ] }, 
  { _id : 131840:22348544, _rev : 22348544, name : Name/-10/0, loc : [ -10, 0 ] } ]
</pre></div> <p>If you need the distance as well, then you can use the <code>distance</code> operator:</p>
<div class="fragment"><pre class="fragment">arango&gt; db.geo.near(0,0).distance().limit(2).toArray();
[ { _id : 131840:24773376, _rev : 24773376, distance : 0, name : Name/0/0, loc : [ 0, 0 ] },
  { _id : 131840:22348544, _rev : 22348544, distance : 1111949.3, name : Name/-10/0, loc : [ -10, 0 ] } ]
</pre></div>  <p><a class="anchor" id="SimpleQueryWithin"></a> <hr/>
<code><b><em>collection</em>.within(<em>latitude</em>, <em>longitude</em>, <em>radius</em>)</b></code><hr/>
<p>This will find all documents with in a given radius around the coordinate (<em>latitude</em>, <em>longitude</em>). The returned list is sorted by distance.</p>
<p>In order to use the <code>within</code> operator, a geo index must be defined for the collection. This index also defines which attribute holds the coordinates for the document. If you have more then one geo-spatial index, you can use the <code>geo</code> operator to select a particular index.</p>
<hr/>
<code><b><em>collection</em>.within(<em>latitude</em>, <em>longitude</em>, <em>radius</em>) .distance()</b></code><hr/>
<p>This will add an attribute <code>_distance</code> to all documents returned, which contains the distance between the given point and the document in meter.</p>
<hr/>
<code><b><em>collection</em>.within(<em>latitude</em>, <em>longitude</em>, <em>radius</em>) .distance(<em>name</em>)</b></code><hr/>
<p>This will add an attribute <em>name</em> to all documents returned, which contains the distance between the given point and the document in meter.</p>
<p><b>Examples</b><br/>
</p>
<p>To find all documents within a radius of 2000 km use:</p>
<div class="fragment"><pre class="fragment">arango&gt; db.geo.within(0, 0, 2000 * 1000).distance().toArray();
[ { _id : 131840:24773376, _rev : 24773376, distance : 0, name : Name/0/0, loc : [ 0, 0 ] }, 
  { _id : 131840:24707840, _rev : 24707840, distance : 1111949.3, name : Name/0/-10, loc : [ 0, -10 ] },
  { _id : 131840:24838912, _rev : 24838912, distance : 1111949.3, name : Name/0/10, loc : [ 0, 10 ] },
  { _id : 131840:22348544, _rev : 22348544, distance : 1111949.3, name : Name/-10/0, loc : [ -10, 0 ] },
  { _id : 131840:27198208, _rev : 27198208, distance : 1111949.3, name : Name/10/0, loc : [ 10, 0 ] },
  { _id : 131840:22414080, _rev : 22414080, distance : 1568520.6, name : Name/-10/10, loc : [ -10, 10 ] },
  { _id : 131840:27263744, _rev : 27263744, distance : 1568520.6, name : Name/10/10, loc : [ 10, 10 ] },
  { _id : 131840:22283008, _rev : 22283008, distance : 1568520.6, name : Name/-10/-10, loc : [ -10, -10 ] },
  { _id : 131840:27132672, _rev : 27132672, distance : 1568520.6, name : Name/10/-10, loc : [ 10, -10 ] } ]
</pre></div>  <p><a class="anchor" id="SimpleQueryGeo"></a> <hr/>
<code><b><em>collection</em>.geo(<em>location</em>)</b></code><hr/>
<p>The next <code>near</code> or <code>within</code> operator will use the specific geo-spatial index.</p>
<hr/>
<code><b><em>collection</em>.geo(<em>location</em>, <code>true</code>)</b></code><hr/>
<p>The next <code>near</code> or <code>within</code> operator will use the specific geo-spatial index.</p>
<hr/>
<code><b><em>collection</em>.geo(<em>latitude</em>, <em>longitude</em>)</b></code><hr/>
<p>The next <code>near</code> or <code>within</code> operator will use the specific geo-spatial index.</p>
<p><b>Examples</b><br/>
</p>
<p>Assume you have a location stored as list in the attribute <code>home</code> and a destination stored in the attribute <code>work</code>. Than you can use the <code>geo</code> operator to select, which coordinates to use in a near query.</p>
<div class="fragment"><pre class="fragment">arango&gt; for (i = -90;  i &lt;= 90;  i += 10) {
.......&gt;   for (j = -180;  j &lt;= 180;  j += 10) {
.......&gt;     db.complex.save({ name : "Name/" + i + "/" + j, 
.......&gt;                       home : [ i, j ], 
.......&gt;                       work : [ -i, -j ] });
.......&gt;   }
.......&gt; }

arango&gt; db.complex.near(0, 170).limit(5);
exception in file '/simple-query' at 1018,5: an geo-index must be known

arango&gt; db.complex.ensureGeoIndex("home");
arango&gt; db.complex.near(0, 170).limit(5).toArray();
[ { _id : 48834092:74655276, _rev : 74655276, name : Name/0/170, home : [ 0, 170 ], work : [ 0, -170 ] },
  { _id : 48834092:74720812, _rev : 74720812, name : Name/0/180, home : [ 0, 180 ], work : [ 0, -180 ] }, 
  { _id : 48834092:77080108, _rev : 77080108, name : Name/10/170, home : [ 10, 170 ], work : [ -10, -170 ] },
  { _id : 48834092:72230444, _rev : 72230444, name : Name/-10/170, home : [ -10, 170 ], work : [ 10, -170 ] },
  { _id : 48834092:72361516, _rev : 72361516, name : Name/0/-180, home : [ 0, -180 ], work : [ 0, 180 ] } ]      

arango&gt; db.complex.geo("work").near(0, 170).limit(5);
exception in file '/simple-query' at 1018,5: an geo-index must be known

arango&gt; db.complex.ensureGeoIndex("work");
arango&gt; db.complex.geo("work").near(0, 170).limit(5).toArray();
[ { _id : 48834092:72427052, _rev : 72427052, name : Name/0/-170, home : [ 0, -170 ], work : [ 0, 170 ] }, 
  { _id : 48834092:72361516, _rev : 72361516, name : Name/0/-180, home : [ 0, -180 ], work : [ 0, 180 ] }, 
  { _id : 48834092:70002220, _rev : 70002220, name : Name/-10/-170, home : [ -10, -170 ], work : [ 10, 170 ] }, 
  { _id : 48834092:74851884, _rev : 74851884, name : Name/10/-170, home : [ 10, -170 ], work : [ -10, 170 ] }, 
  { _id : 48834092:74720812, _rev : 74720812, name : Name/0/180, home : [ 0, 180 ], work : [ 0, -180 ] } ]
</pre></div>  <h2><a class="anchor" id="SimpleQueriesPagination"></a>
Pagination</h2>
<p>If, for example, you display the result of a user search, then you are in general not interested in the completed result set, but only the first 10 or so documents. Or maybe the next 10 documents for the second page. In this case, you can the <code>skip</code> and <code>limit</code> operators. These operators work like LIMIT in MySQL.</p>
<p><code>skip</code> used together with <code>limit</code> can be used to implement pagination. The <code>skip</code> operator skips over the first n documents. So, in order to create result pages with 10 result documents per page, you can use <code>skip(n * 10).limit(10)</code> to access the 10 documents on the n.th page. This result should be sorted, so that the pagination works in a predicable way.</p>
<p><a class="anchor" id="SimpleQueryLimit"></a> <hr/>
<code><b><em>query</em>.limit(<em>number</em>)</b></code><hr/>
 Limits a result to the first <em>number</em> documents. Specifying a limit of <code>0</code> returns no documents at all. If you do not need a limit, just do not add the limit operator. The limit must be non-negative.</p>
<p>In general the input to <code>limit</code> should be sorted. Otherwise it will be unclear which documents are used in the result set.</p>
<p><b>Examples</b><br/>
</p>
<div class="fragment"><pre class="fragment">arango&gt; db.five.all().toArray();
[ { _id : 159896:1798296, _rev : 1798296, doc : 3 },
  { _id : 159896:1732760, _rev : 1732760, doc : 2 },
  { _id : 159896:1863832, _rev : 1863832, doc : 4 },
  { _id : 159896:1667224, _rev : 1667224, doc : 1 },
  { _id : 159896:1929368, _rev : 1929368, doc : 5 } ]

arango&gt; db.five.all().limit(2).toArray();
[ { _id : 159896:1798296, _rev : 1798296, doc : 3 },
  { _id : 159896:1732760, _rev : 1732760, doc : 2 } ]

arango&gt; db.five.all().limit(-2);
[ { _id : 159896:1667224, _rev : 1667224, doc : 1 },
  { _id : 159896:1929368, _rev : 1929368, doc : 5 } ]
</pre></div> <p><a class="anchor" id="SimpleQuerySkip"></a> <hr/>
<code><b><em>query</em>.skip(<em>number</em>)</b></code><hr/>
 Skips the first <em>number</em> documents. If <em>number</em> is positive, then skip the number of documents. If <em>number</em> is negative, then the total amount N of documents must be known and the results starts at position (N + <em>number</em>).</p>
<p>In general the input to <code>limit</code> should be sorted. Otherwise it will be unclear which documents are used in the result set.</p>
<p><b>Examples</b><br/>
</p>
<div class="fragment"><pre class="fragment">arango&gt; db.five.all().toArray();
[ { _id : 159896:1798296, _rev : 1798296, doc : 3 },
  { _id : 159896:1732760, _rev : 1732760, doc : 2 },
  { _id : 159896:1863832, _rev : 1863832, doc : 4 },
  { _id : 159896:1667224, _rev : 1667224, doc : 1 },
  { _id : 159896:1929368, _rev : 1929368, doc : 5 } ]

arango&gt; db.five.all().skip(3).toArray();
[ { _id : 159896:1667224, _rev : 1667224, doc : 1 },
  { _id : 159896:1929368, _rev : 1929368, doc : 5 } ]
</pre></div> <h2><a class="anchor" id="SimpleQueriesCursor"></a>
Sequential Access and Cursors</h2>
<p><a class="anchor" id="SimpleQueryHasNext"></a> <hr/>
<code><b><em>cursor</em>.hasNext()</b></code><hr/>
 The <code>hasNext</code> operator returns <code>true</code>, then the cursor still has documents. In this case the next document can be accessed using the <code>next</code> operator, which will advance the cursor.</p>
<p><b>Examples</b><br/>
</p>
<div class="fragment"><pre class="fragment">arango&gt; var a = db.five.all();
arango&gt; while (a.hasNext()) print(a.next());
{ _id : 159896:1798296, _rev : 1798296, doc : 3 }
{ _id : 159896:1732760, _rev : 1732760, doc : 2 }
{ _id : 159896:1863832, _rev : 1863832, doc : 4 }
{ _id : 159896:1667224, _rev : 1667224, doc : 1 }
{ _id : 159896:1929368, _rev : 1929368, doc : 5 }
</pre></div> <p><a class="anchor" id="SimpleQueryNext"></a> <hr/>
<code><b><em>cursor</em>.next()</b></code><hr/>
 If the <code>hasNext</code> operator returns <code>true</code>, then the underlying cursor of the simple query still has documents. In this case the next document can be accessed using the <code>next</code> operator, which will advance the underlying cursor. If you use <code>next</code> on an exhausted cursor, then <code>undefined</code> is returned.</p>
<p><b>Examples</b><br/>
</p>
<div class="fragment"><pre class="fragment">arango&gt; db.five.all().next();
{ _id : 159896:1798296, _rev : 1798296, doc : 3 }
</pre></div> <p><a class="anchor" id="SimpleQuerySetBatchSize"></a> <hr/>
<code><b><em>cursor</em>.setBatchSize(<em>number</em>)</b></code><hr/>
 Sets the batch size for queries. The batch size determines how many results are at most transferred from the server to the client in one chunk. </p>
<p><a class="anchor" id="SimpleQueryGetBatchSize"></a> <hr/>
<code><b><em>cursor</em>.getBatchSize()</b></code><hr/>
 Returns the batch size for queries. If the returned value is undefined, the server will determine a sensible batch size for any following requests. </p>
<p><a class="anchor" id="SimpleQueryExecute"></a> <hr/>
<code><b><em>query</em>.execute(<em>batchSize</em>)</b></code><hr/>
 Executes a simple query. If the optional <em>batchSize</em> value is specified, the server will return at most <code>batchSize</code> values in one roundtrip. The <em>batchSize</em> cannot be adjusted after the query is first executed.</p>
<p>Note that there is no need to explicitly call the execute method if another means of fetching the query results is chosen. The following two approaches lead to the same result: </p>
<div class="fragment"><pre class="fragment"> result = db.users.all().toArray();
 q = db.users.all(); q.execute(); result = [ ]; <span class="keywordflow">while</span> (q.hasNext()) { result.push(q.next()); }
</pre></div><p>The following two alternatives both use a <em>batchSize</em> and return the same result: </p>
<div class="fragment"><pre class="fragment"> q = db.users.all(); q.setBatchSize(20); q.execute(); <span class="keywordflow">while</span> (q.hasNext()) { print(q.next()); }
 q = db.users.all(); q.execute(20); <span class="keywordflow">while</span> (q.hasNext()) { print(q.next()); }
</pre></div> <p><a class="anchor" id="SimpleQueryDispose"></a> <hr/>
<code><b><em>cursor</em>.dispose()</b></code><hr/>
 If you are no longer interested in any further results, you should call <code>dispose</code> in order to free any resources associated with the cursor. After calling <code>dispose</code> you can no longer access the cursor. </p>
<p><a class="anchor" id="SimpleQueryCount"></a> <hr/>
<code><b><em>cursor</em>.count()</b></code><hr/>
 The <code>count</code> operator counts the number of document in the result set and returns that number. The <code>count</code> operator ignores any limits and returns the total number of documents found.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all simple queries support counting. In this case <code>null</code> is returned.</dd></dl>
<hr/>
<code><b><em>cursor</em>.count(<code>true</code>)</b></code><hr/>
 If the result set was limited by the <code>limit</code> operator or documents were skiped using the <code>skip</code> operator, the <code>count</code> operator with argument <code>true</code> will use the number of elements in the final result set - after applying <code>limit</code> and <code>skip</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all simple queries support counting. In this case <code>null</code> is returned.</dd></dl>
<p><b>Examples</b><br/>
</p>
<p>Ignore any limit:</p>
<div class="fragment"><pre class="fragment">arango&gt; db.five.all().limit(2).count();
5
</pre></div><p>Counting any limit or skip:</p>
<div class="fragment"><pre class="fragment">arango&gt; db.five.all().limit(2).count(true);
2
</pre></div>  </div></div>
</div></body></html>
