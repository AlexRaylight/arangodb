!CHAPTER Graph Module

The graph module provides functions dealing with graph structures.

!SECTION First Steps with Graphs

A Graph consists of *vertices* and *edges*. Edges are stored as documents in *edge
collections*. A vertex can be a document of a *document collection* or of an edge
collection (so edges can be used as vertices). Which collections are used within
a graph is defined via *edge definitions*. A graph can contain more than one edge
definition, at least one is needed.

!SUBSECTION Create a graph

The creation of a graph requires the name of the graph and a definition of its edges.

For every type of edge definition a convenience method exists that can be used to create a graph.

```js
> var graph = require("org/arangodb/graph");

> var g = graph._create(graphName, edgeDefinitions);
```

There are different types of edge defintions:

!SUBSECTION Edge Definitions

<!-- @startDocuBlock @startDocuBlock JSF_general_graph_edgeDefinitions -->


To add further edge definitions to the array one must call:

```js
> graph._extendEdgeDefinitions(edgeDefinitions, edgeDefinition1,......edgeDefinitionN);
```


!SUBSUBSECTION Undirected Relation


<br />
`general-graph._undirectedRelationDefinition(relationName, vertexCollections)`
*Define an undirected relation.*
<br />
Defines an undirected relation with the name *relationName* using the
list of *vertexCollections*. This relation allows the user to store
edges in any direction between any pair of vertices within the
*vertexCollections*.
<br />
@EXAMPLES
<br />
To define simple relation with only one vertex collection:
<br />

```
arangosh>   var graph = require("org/arangodb/general-graph");
arangosh>   graph._undirectedRelationDefinition("friend", "user");
{
  "collection" : "friend",
  "from" : [
    "user"
  ],
  "to" : [
    "user"
  ]
}
```
<br />
To define a relation between several vertex collections:
<br />

```
arangosh>   var graph = require("org/arangodb/general-graph");
arangosh>   graph._undirectedRelationDefinition("marriage", ["female", "male"]);
{
  "collection" : "marriage",
  "from" : [
    "female",
    "male"
  ],
  "to" : [
    "female",
    "male"
  ]
}
```


!SUBSUBSECTION Directed Relation


<br />
`general-graph._directedRelationDefinition(relationName, fromVertexCollections, toVertexCollections)`
*Define a directed relation.*
<br />
The *relationName* defines the name of this relation and references to the underlying edge collection.
The *fromVertexCollections* is an Array of document collections holding the start vertices.
The *toVertexCollections* is an Array of document collections holding the target vertices.
Relations are only allowed in the direction from any collection in *fromVertexCollections*
to any collection in *toVertexCollections*.
<br />
@EXAMPLES
<br />

```
arangosh>   var graph = require("org/arangodb/general-graph");
arangosh>   graph._directedRelationDefinition("has_bought", ["Customer", "Company"], ["Groceries", "Electronics"]);
{
  "collection" : "has_bought",
  "from" : [
    "Customer",
    "Company"
  ],
  "to" : [
    "Groceries",
    "Electronics"
  ]
}
```



!SUBSUBSECTION Complete Example to create a graph

Example Call:

```js
> var graph = require("org/arangodb/graph");
> var edgeDefinitions = graph._edgeDefinitions();
> graph._extendEdgeDefinitions(edgeDefinitions, graph._undirectedRelationDefinition("friend_of", ["Customer"]));
> graph._extendEdgeDefinitions(edgeDefinitions, graph._directedRelationDefinition("has_bought", ["Customer", "Company"], ["Groceries", "Electronics"]));
> graph._create("myStore", edgeDefinitions);
{
  _id: "_graphs/123",
  _rev: "123",
  _key: "123"
}
```

alternative call:

```js
> var graph = require("org/arangodb/graph");
> var edgeDefinitions = graph._edgeDefinitions(graph._undirectedRelationDefinition("friend_of", ["Customer"]), graph._directedRelationDefinition("has_bought", ["Customer", "Company"], ["Groceries", "Electronics"]));
> graph._create("myStore", edgeDefinitions);
{
  _id: "_graphs/123",
  _rev: "123",
  _key: "123"
};
```
!SUBSECTION Orphan Collections

Each graph has a list of orphan collections. It consists of arbitrary many vertex collections (type *document*), that are not
used in an edge definition of the graph. If the graph is extended with an edge definition using one of the orphans,
it will be removed from the orphan collections automatically.

!SUBSUBSECTION Add


Adds a vertex collection to the set of orphan collections of the graph. If the
collection does not exist, it will be created.
<br />
`general-graph._addOrphanCollection(orphanCollectionName, createCollection)`
<br />
*orphanCollectionName* - string : name of vertex collection.
*createCollection* - bool : if true the collection will be created if it does not exist. Default: true.
<br />
@EXAMPLES
<br />

```
arangosh>   var graph = require("org/arangodb/general-graph")
arangosh>   var ed1 = graph._directedRelationDefinition("myEC1", ["myVC1"], ["myVC2"]);
arangosh>   var g = graph._create("myGraph", [ed1, ed2]);
ReferenceError: ed2 is not defined
```
<br />


!SUBSUBSECTION Read


Returns all vertex collections of the graph, that are not used in an edge definition.
<br />
`general-graph._getOrphanCollections()`
<br />
@EXAMPLES
<br />

```
arangosh>   var graph = require("org/arangodb/general-graph")
arangosh>   var ed1 = graph._directedRelationDefinition("myEC1", ["myVC1"], ["myVC2"]);
arangosh>   var g = graph._create("myGraph", [ed1]);
[ArangoError 1925: graph already exists]
```
<br />


!SUBSUBSECTION Remove


Removes an orphan collection from the graph and deletes the collection, if it is not
used in any graph.
<br />
`general-graph._removeOrphanCollection()`
<br />
*orphanCollectionName* - string : name of vertex collection.
*dropCollection* - bool : if true the collection will be dropped if it is not used in any graph.
Default: true.
<br />
@EXAMPLES
<br />

```
arangosh>   var graph = require("org/arangodb/general-graph")
arangosh>   var ed1 = graph._directedRelationDefinition("myEC1", ["myVC1"], ["myVC2"]);
arangosh>   var g = graph._create("myGraph", [ed1]);
[ArangoError 1925: graph already exists]
```
<br />


!SUBSECTION Read a graph

```js
> var graph = require("org/arangodb/graph");

> var g = graph._graph("myStore");
```

- - -

!SUBSECTION Remove a graph


Removes a graph from the collection *\_graphs*.

```js
> graph._drop(graphId, dropCollections);
true
```

graphId: string - id of the graph to be removed
dropCollections: bool - optional. *true* all collections of the graph will be deleted.
*false* no collection of the graph will be deleted. Default: *true*



!SECTION Vertex

!SUBSECTION Save


Creates and saves a new vertex in collection *vertexCollectionName*
<br />
`general-graph.vertexCollectionName.save(data)`
<br />
*data*: json - data of vertex
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g.male.save({name: "Floyd", _key: "floyd"});
{
  "error" : false,
  "_id" : "male/floyd",
  "_rev" : "91260521",
  "_key" : "floyd"
}
```
<br />


!SUBSECTION Replace


Replaces the data of a vertex in collection *vertexCollectionName*
<br />
`general-graph.vertexCollectionName.replace(vertexId, data, options)`
<br />
*vertexId*: string - id of the vertex
*data*: json - data of vertex
*options*: json - (optional) - see collection documentation
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g.male.save({neym: "Jon", _key: "john"});
{
  "error" : false,
  "_id" : "male/john",
  "_rev" : "31360617",
  "_key" : "john"
}
arangosh>   g.male.replace("male/john", {name: "John"});
{
  "error" : false,
  "_id" : "male/john",
  "_rev" : "31557225",
  "_key" : "john"
}
```
<br />


!SUBSECTION Update


Updates the data of a vertex in collection *vertexCollectionName*
<br />
`general-graph.vertexCollectionName.update(vertexId, data, options)`
<br />
*vertexId*: string - id of the vertex
*data*: json - data of vertex
*options*: json - (optional) - see collection documentation
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g.female.save({name: "Lynda", _key: "linda"});
{
  "error" : false,
  "_id" : "female/linda",
  "_rev" : "79201897",
  "_key" : "linda"
}
arangosh>   g.female.update({name: "Linda", _key: "linda"});
TypeError: Object #<Object> has no method 'split'
```
<br />


!SUBSECTION Remove


Removes a vertex in collection *vertexCollectionName*
<br />
`general-graph.vertexCollectionName.remove(vertexId, options)`
<br />
Additionally removes all ingoing and outgoing edges of the vertex recursively
(see [edge remove](#edge.remove)).
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g.male.save({name: "Kermit", _key: "kermit"});
{
  "error" : false,
  "_id" : "male/kermit",
  "_rev" : "83068521",
  "_key" : "kermit"
}
arangosh>   db._exists("male/kermit")
true
arangosh>   g.male.remove("male/kermit")
true
arangosh>   db._exists("male/kermit")
false
```
<br />


!SECTION Edge

!SUBSECTION Save


Creates and saves a new edge from vertex *from* to vertex *to* in
collection *edgeCollectionName*
<br />
`general-graph.edgeCollectionName.save(from, to, data)`
<br />
*from*: string - id of outgoing vertex
*to*: string -  of ingoing vertex
*data*: json - data of edge
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g.relation.save("male/bob", "female/alice", {type: "married", _key: "bobAndAlice"});
{
  "error" : false,
  "_id" : "relation/bobAndAlice",
  "_rev" : "45909609",
  "_key" : "bobAndAlice"
}
```
<br />
If the collections of *from* and *to* are not defined in an edgeDefinition of the graph,
the edge will not be stored.
<br />
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g.relation.save("relation/aliceAndBob", "female/alice", {type: "married", _key: "bobAndAlice"});
Edge is not allowed between relation/aliceAndBob and female/alice.
```


!SUBSECTION Replace


Replaces the data of an edge in collection *edgeCollectionName*
<br />
`general-graph.edgeCollectionName.replace(edgeId, data, options)`
<br />
*edgeId*: string - id of the edge
*data*: json - data of edge
*options*: json - (optional) - see collection documentation
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g.relation.save("female/alice", "female/diana", {typo: "nose", _key: "aliceAndDiana"});
{
  "error" : false,
  "_id" : "relation/aliceAndDiana",
  "_rev" : "27362921",
  "_key" : "aliceAndDiana"
}
arangosh>   g.relation.replace("relation/aliceAndDiana", {type: "knows"});
{
  "error" : false,
  "_id" : "relation/aliceAndDiana",
  "_rev" : "27559529",
  "_key" : "aliceAndDiana"
}
```
<br />


!SUBSECTION Update


Updates the data of an edge in collection *edgeCollectionName*
<br />
`general-graph.edgeCollectionName.update(edgeId, data, options)`
<br />
*edgeId*: string - id of the edge
*data*: json - data of edge
*options*: json - (optional) - see collection documentation
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g.relation.save("female/alice", "female/diana", {type: "knows", _key: "aliceAndDiana"});
{
  "error" : false,
  "_id" : "relation/aliceAndDiana",
  "_rev" : "127108713",
  "_key" : "aliceAndDiana"
}
arangosh>   g.relation.update("relation/aliceAndDiana", {type: "quarrelled", _key: "aliceAndDiana"});
{
  "error" : false,
  "_id" : "relation/aliceAndDiana",
  "_rev" : "127305321",
  "_key" : "aliceAndDiana"
}
```
<br />


!SUBSECTION Remove


Removes an edge in collection *edgeCollectionName*
<br />
`general-graph.edgeCollectionName.remove(edgeId, options)`
<br />
If this edge is used as a vertex by another edge, the other edge will be removed (recursively).
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g.relation.save("female/alice", "female/diana", {_key: "aliceAndDiana"});
{
  "error" : false,
  "_id" : "relation/aliceAndDiana",
  "_rev" : "141657705",
  "_key" : "aliceAndDiana"
}
arangosh>   db._exists("relation/aliceAndDiana")
true
arangosh>   g.relation.remove("relation/aliceAndDiana")
true
arangosh>   db._exists("relation/aliceAndDiana")
false
```
<br />


!SECTION Vertices

!SUBSECTION Get vertex *from* of an edge


Get the vertex of an edge defined as *_from*
<br />
`general-graph._getFromVertex(edgeId)`
<br />
Returns the vertex defined with the attribute *_from* of the edge with *edgeId* as its *_id*.
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g._getFromVertex("relation/aliceAndBob")
{
  "name" : "Alice",
  "_id" : "female/alice",
  "_rev" : "175670889",
  "_key" : "alice"
}
```
<br />


!SUBSECTION Get vertex *to* of an edge


Get the vertex of an edge defined as *_to*
<br />
`general-graph._getToVertex(edgeId)`
<br />
Returns the vertex defined with the attribute *_to* of the edge with *edgeId* as its *_id*.
<br />
@EXAMPLES
<br />

```
arangosh>   var examples = require("org/arangodb/graph-examples/example-graph.js");
arangosh>   var g = examples.loadGraph("social");
arangosh>   g._getToVertex("relation/aliceAndBob")
{
  "name" : "Bob",
  "_id" : "male/bob",
  "_rev" : "40666729",
  "_key" : "bob"
}
```
<br />



!SECTION Some Methods

```javascript
graph.listCommonNeighbors(vertex1, vertex2, options)
```

vertex1: string - vertex id
vertex2: string - vertex id
options:
* see getNeighbors

```javascript
graph.amountCommonNeighbors(vertex1, vertex2, options)
```

vertex1: string - vertex id
vertex2: string - vertex id
options:
* see getNeighbors



```javascript
graph.listCommonProperties((vertex1, vertex2)
```

vertex1: string - vertex id
vertex2: string - vertex id


```javascript
graph.amountCommonProperties((vertex1, vertex2)
```

vertex1: string - vertex id
vertex2: string - vertex id




```javascript
graph.pathTo(vertex1, vertex2, options)
```


vertex1: string - vertex id
vertex2: string - vertex id
options:  see determinePredecessors


```javascript
graph.distanceTo(vertex1, vertex2, options)
```


vertex1: string - vertex id
vertex2: string - vertex id
options: see determinePredecessors


```javascript
graph.determinePredecessors(vertex1, source, options)
```


vertex1: string - vertex id
source: ???
options:
* cached: Boolean -> If true a cached version will be used


```javascript
graph.pathesForTree(vertex1, tree, path_to_here)
```

vertex1: string - vertex id
tree: ???
path_to_here: Internal Array, should initially be undefined or an empty array


```javascript
graph.getNeighbors(vertex1, options)
```

vertex1: string - vertex id
options:

* direction:
  "inbound" -> consider only inbound edges
  "outbount" -> consider only outbound edges
  "any"(default) -> consider both directions
* weight: attribute-name -> use this attribute to determine edgeweight
* weight_function: function -> use this function to calculate the weight
* default-weight -> us this value if weight could not be calculated otherwise, default is Infinity
* only: function -> will be invoked on any edge, neighbors will only be included if this returns true or is not defined.


```javascript
graph.measurement(vertex1, measurement)
```

vertex1: string - vertex id
measurement: String
*  "eccentricity": Calculates the eccentricity of the vertex
*  "betweenness": Calculates the betweenness of the vertex
*  "closeness": Calculates the closeness of the vertex

!SECTION Using Graphs in AQL {#JSModuleGraphAQL}

Complete Documentation can be copied from normal AQL documentation, with:

* replace VertexCollection/EdgeCollection by Graph

!SUBSECTION PATHS

* **BUILD ON** `ahuacatl.js`: 4090 `GRAPH_PATHS` -> uses `COLLECTION` on second arg, has to use `COLLECTION` or `GRAPH` accordingly. Has to pass the graph to traverser

Paths returns a handle for all paths included in the graph:

`GRAPH_PATHS(graphname, direction, followcycles)`

* `graphname` defines the graph
* `direction` defines the direction
* `followcycles` defines if cyclic paths should be followed

Example calls:

```javascript
FOR p in PATHS(shop, "outbound")
  FILTER p.source._id == "123456/123456" && LENGTH(p.edges) == 2
  RETURN p.vertices[*].name
```


!SUBSECTION TRAVERSAL


`GRAPH_TRAVERSAL(graphname, startVertex, direction, options)}`

* **BUILD ON** `ahuacatl.js`: 4243 `TRAVERSAL_FUNC` -> uses `COLLECTION` on first and second arg, has to use `COLLECTION` or `GRAPH` accordingly. Has to pass the graph to traverser
* **TO CHANGE** `common/modules/org/arangodb/graph/traversal.js`: 106 `collectionDatasourceFactory` should be able to work on Graphs

Traverses the graph described by the `graphname`,
starting at the vertex identified by id `startVertex`. Vertex connectivity is
specified by the `direction` parameter:

- `"outbound"`: Vertices are connected in `_from` to `_to` order
- `"inbound"`: Vertices are connected in `_to` to `_from` order
- `"any"`: Vertices are connected in both `_to` to `_from` and in
  `_from` to `_to` order

All this is defined already for TRAVERSAL, no changes should be applied here

```javascript
TRAVERSAL(shop, "products/arangodb", "outbound", {
  strategy: "depthfirst",
  order: "postorder",
  itemOrder: "backward",
  maxDepth: 6,
  paths: true
})
```


!SUBSECTION TRAVERSAL_TREES

`GRAPH_TRAVERSAL_TREE(graphname, startVertex, direction, connectName, options)`

* **BUILD ON** `ahuacatl.js`: 4243 `TRAVERSAL_FUNC` -> uses `COLLECTION` on first and second arg, has to use `COLLECTION` or `GRAPH` accordingly. Has to pass the graph to traverser
* **TO CHANGE** `common/modules/org/arangodb/graph/traversal.js`: 106 `collectionDatasourceFactory` should be able to work on Graphs

```javascript
GRAPH_TRAVERSAL_TREE(shop, "products/arangodb", "inbound", "sold", {
  itemOrder: "forward"
})
```

Makes internal use of TRAVERSAL, modyfing that is sufficient.

!SUBSECTION SHORTEST_PATHS


* **BUILD ON** `ahuacatl.js`: 4243 `TRAVERSAL_FUNC` -> uses `COLLECTION` on first and second arg, has to use `COLLECTION` or `GRAPH` accordingly. Has to pass the graph to traverser
* **TO CHANGE** `common/modules/org/arangodb/graph/traversal.js`: 106 `collectionDatasourceFactory` should be able to work on Graphs

`GRAPH_SHORTEST_PATH(graphname, startVertex, endVertex, direction, options)`:

Equal to functionality of `SHORTEST_PATH`.
Makes internal use of TRAVERSAL, modyfing that is sufficient.


!SUBSECTION EDGES


* **BUILD ON** `ahuacatl.js`: 4479 `GRAPH_EDGES` -> uses `COLLECTION` on first argument, has to use `COLLECTION` or `GRAPH` accordingly.

`GRAPH_EDGES(graphname, startvertex, direction, edgeexamples, collectionRestrictions)`

Same as original, but with optional `collectionRestrictions`to define which edge collections have to be included. Default is all.


!SUBSECTION NEIGHBORS


* **BUILD ON** `ahuacatl.js`: 4508 `GRAPH_NEIGHBORS` -> uses `COLLECTION` on first, has to use `COLLECTION` or `GRAPH` accordingly.

`GRAPH_NEIGHBORS(graphname, startvertex, direction, edgeexamples)`

* Each of the graph functions in AQL (`PATHS`, `TRAVERSAL`, `TRAVERSAL_TREES`, `SHORTEST_PATHS`, `EDGES`, `NEIGHBORS`) will take the graph as its first argument (which parts of the other arguments will be pushed to be defined in FILTER and not in the signature of the function was discussed, but postponed because it is a detail).

